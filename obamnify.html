<!TEMPLATE /cardpage.html>
<head>
    <title>Obamnify (obamify remake)</title>
    <meta name="description" content="I wanted an obamify but like on my phone, and can do video transformation aswell">
</head>
<body>
    <form id="input" style="display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 10px;" method="dialog">
        <div>
            <label>File to transform</label><br>
            <input id="source" type="file" accept="image/*">
        </div>

        <div>
            <label>File to become</label><br>
            <input id="target" type="file" accept="image/*,video/*">
        </div>

        <div>
            <label for="use-previous">Use previous frames</label>
            <input id="use-previous" type="checkbox" title="If the previous video frame should be used">
        </div>

        <button onclick="transform()">Generate</button>
    </form><br>
    <span>video progress:</span>
    <progress id="video-progress" min="0" max="100"></progress><br>
    <span>conversion progresses:</span>
    <div id="conversion-progress"></div><br>
    <canvas hidden style="width: 100%; height: 100%; object-fit: fill; image-rendering: pixelated;" id="preview"></canvas>
    <script file="jsx">
        const fps = 30;
        /** @type {HTMLDivElement} */
        const conversionProgress = document.getElementById('conversion-progress');
        /** @type {HTMLProgressElement} */
        const videoProgress = document.getElementById('video-progress');
        /** @type {HTMLFormElement} */
        const inputForm = document.getElementById('input');
        /** @type {HTMLInputElement} */
        const sourceInput = document.getElementById('source');
        /** @type {HTMLInputElement} */
        const targetInput = document.getElementById('target');
        /** @type {HTMLInputElement} */
        const usePreviousInput = document.getElementById('use-previous');
        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('preview');
        const dim = canvas.getBoundingClientRect();
        const ctx = canvas.getContext('2d');
        function playFrames(frames) {
            let i = 0;
            canvas.width = frames[0].width;
            canvas.height = frames[0].height;
            videoProgress.max = frames.length;
            console.log('playing back', frames);
            setInterval(() => {
                ctx.putImageData(frames[i = (i +1) % frames.length], 0,0);
                videoProgress.value = i;
            }, 1000 / fps);
        }
        async function transform() {
            inputForm.hidden = true;
            canvas.hidden = false;
            conversionProgress.hidden = false;
            const keepPrevious = usePreviousInput.checked;
            const sourceFile = URL.createObjectURL(sourceInput.files[0]);
            const source = await loadImage(sourceFile);
            const w = 20;
            const h = 20;
            canvas.width = w * 3;
            canvas.height = h;
            ctx.drawImage(source, 0,0, w,h);
            const sourceData = ctx.getImageData(0,0, w,h);

            const isVideo = targetInput.files[0].type.startsWith('video');
            const targetFile = URL.createObjectURL(targetInput.files[0]);
            if (!isVideo) {
                const target = await loadImage(targetFile);
                canvas.width = sourceData.width;
                canvas.height = sourceData.height;
                ctx.drawImage(target, 0,0, w,h);
                const targetData = ctx.getImageData(0,0, w,h);
                ctx.putImageData(targetData, 40,0);
                ctx.putImageData(sourceData, 20,0);
                transformFrame(sourceData, targetData);
                return;
            }
            videoProgress.hidden = false;
            const video = await loadVideo(targetFile)
            // workaround chromium metadata bug (https://stackoverflow.com/q/38062864/993683)
            while (
                (video.duration === Infinity || isNaN(video.duration)) &&
                video.readyState < 2
            ) {
                await new Promise((r) => setTimeout(r, 1000));
                video.currentTime = 10000000 * Math.random();
            }
            const duration = video.duration;
            videoProgress.max = duration;
            const interval = 1 / fps;
            let currentTime = 0;
            const frames = [sourceData];
            let i = 0;
            async function captureFrame() {
                if (currentTime >= duration) return playFrames(frames);
                
                ctx.drawImage(video, 0,0, w,h);
                const targetData = ctx.getImageData(0,0, w,h);
                const idx = i;
                const source = usePreviousInput.checked ? frames.at(-1) : sourceData;
                ctx.clearRect(0,0, canvas.width, canvas.height);
                ctx.putImageData(targetData, 40,0);
                ctx.putImageData(source, 20,0);
                await transformFrame(source, targetData, w,h)
                    .then(frame => frames[idx] = frame);
                i++;

                videoProgress.value = currentTime;
                currentTime += interval;
                video.currentTime = currentTime;
            }
            video.addEventListener("seeked", captureFrame);
            video.currentTime = 0;
            captureFrame();
        }
        function transformFrame(source, target, w,h) {
            return new Promise(resolve => {
                const progress = document.createElement('progress');
                progress.min = 0;
                conversionProgress.appendChild(progress);
                const sourceColors = new Array(source.data.length / 4).fill(0);
                const targetColors = new Array(target.data.length / 4).fill(0);
                console.log('generating source pallet, total pixels to process:', source.data.length / 4);
                progress.max = source.data.length;
                const sourcePallete = [...source.data]
                    .reduce((pallet, color, idx, arr) => {
                        if (!(idx % 4)) {
                            console.log('source pixel');
                            progress.value = idx;
                            const color = BigInt(arr[idx +3]) |
                                (BigInt(arr[idx +2]) << 8n) |
                                (BigInt(arr[idx +1]) << 16n) |
                                (BigInt(arr[idx +0]) << 24n);
                            if (!pallet.includes(color)) pallet.push(color);
                            sourceColors[idx / 4] = pallet.indexOf(color);
                            return pallet;
                        }
                        return pallet;
                    }, []);
                console.log('generating target pallet, total pixels to process:', target.data.length / 4);
                progress.max = target.data.length;
                const targetPallete = [...target.data]
                    .reduce((pallet, color, idx, arr) => {
                        if (!(idx % 4)) {
                            progress.value = idx;
                            console.log('target pixel');
                            const color = BigInt(arr[idx +3]) |
                                (BigInt(arr[idx +2]) << 8n) |
                                (BigInt(arr[idx +1]) << 16n) |
                                (BigInt(arr[idx +0]) << 24n);
                            if (!pallet.includes(color)) pallet.push(color);
                            targetColors[idx / 4] = pallet.indexOf(color);
                            return pallet;
                        }
                        return pallet;
                    }, []);
                ctx.putImageData(source, 0,0);
                progress.max = targetColors.length;
                let off = 0;
                console.log('sorting/drawing pixels, total pixels to process:', targetColors.length);
                while (true) {
                    if (off >= targetColors.length) {
                        resolve(ctx.getImageData(0,0, w,h));
                        progress.remove();
                        return;
                    }
                    const i = off % targetColors.length;
                    progress.value = off;
                    console.log('sorted pixel');
                    const nearest = sourcePallete
                        .map((color, idx) => [Math.abs(Number(color - targetPallete[targetColors[i]])), idx])
                        .sort((a,b) => a[0] - b[0]);
                    const toUse = findRandom(sourceColors, nearest[0][1]);
                    if (toUse === -1) return;
                    const toSwap = sourceColors[i];
                    sourceColors[i] = sourceColors[toUse];
                    sourceColors[toUse] = toSwap;
                    ctx.fillStyle = '#' + sourcePallete[sourceColors[i]].toString(16).padStart(8, '0');
                    ctx.fillRect(i % w, Math.floor(i / w), 1,1);
                    ctx.fillStyle = '#' + sourcePallete[sourceColors[toUse]].toString(16).padStart(8, '0');
                    ctx.fillRect(toUse % w, Math.floor(toUse / w), 1,1);
                    off++;
                }
            });
        }
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = reject;
                image.src = url;
            });
        }
        function loadVideo(videoUrl, fps = 25) {
            return new Promise((resolve, reject) => {
                const video = document.createElement("video");
                video.oncanplaythrough = () => resolve(video);
                video.onerror = reject;
                video.src = videoUrl;
            });
        }
        function findRandom(array, item) {
            const pos = Math.floor(Math.random() * array.length);
            const forward = array.indexOf(item, pos);
            if (forward !== -1) return forward;
            const backward = array.lastIndexOf(item, pos);
            return backward;
        }
    </script>
</body>